  之前在点亮GCB灯的时候说过，指南者配有三种颜色的LED灯，要是只靠这三种灯颜色的简单叠加，也就只能亮出几种常见颜色的灯光。但是如果你输出PWM信号到这三个LED灯上，那就可以调出所有颜色的灯光。

  这一章本质是通用TIM的运用而已，但是还是有需要讲的点

  首先，先提大致原理：初始化相关的GPIO引脚，然后配置TIM的时基和输出结构体，使能相关通道。然后往相关的比较结构体存入一定的值(即PWM信号的脉宽)，这样就可以调出各种各样颜色的灯

  原理非常简单吧，直接点亮一个颜色的灯非常简单。但是如果我加一个条件。我想在一段时间后换一个其他颜色的灯光，要如何做呢？

  我想你的第一反应是那还不简单吗，直接把要改变的脉宽写入到比较结构体里面就好了啊。

  但是这样是不稳妥的做法，如果新的比较寄存器的值(CCR)被直接写进去了的话，如果你写入的时机正好是一个PWM周期的结束，那就不会有影响。但如果TIM正按照比较寄存器输出的值输出PWM信号呢，你突然把比较寄存器的值，轻者导致当前计数周期
被打断，重则会出现输出波形异常(如亮度闪烁、电机抖动).

  这就是这一节需要单独拎出来进行讲解的地方，也就是在TIM的章节漏讲的，或者说是没有机会讲的--影子寄存器

  我们把TIM的功能框图拎出来

  <img width="877" height="835" alt="image" src="https://github.com/user-attachments/assets/314b9f9c-af6a-457f-95b8-7f5ff8c9c2bf" />

  有没有发现有几个寄存器有阴影，那个就被我们形象地称为影子，这类影子所表示的寄存器就是说的影子寄存器。

  其实，影子寄存器也就是预加载寄存器，而面上的那个寄存器被官方称为工作寄存器。也就是说，为了不突然打断工作中的寄存器从而出现设备异常，我们需要把数据存储到其影子寄存器中，等计数器计数完了一个周期产生了一个事件，影子寄存器
就把新修改的数据传递给工作寄存器中。

  由图可知，含有影子寄存器的寄存器有分频寄存器 PSC;自动重装载寄存器 ARR和捕获 / 比较寄存器 CCRx。

  那么我们如何使能影子寄存器(开启预装载)呢，调用含有PreloadConfig字眼的函数，就是开启了预装载寄存器。当你需要改变数据时，你仅仅需要正常写入到CCR/ARR寄存器即可。数据会先存到影子寄存器中，直到一个周期结束后，才会把数据传递
给工作寄存器。

  我个人建议，即使你不修改数据，一直开着习惯调用着它也无妨，不影响。

  在配置全彩灯时，我们把CNT计数的最大值设置为255，这样我们可以通过配置比较寄存器(CCR)，把脉冲信号占空比分成 256 个等级，即可用于控制 LED 灯输出 256 种亮度，使用三种这样的信号控制 RGB 灯即可得到 256*256*256 种颜色混合的效果。

  如果你用的是指南者，需要注意的是这里开启的TIM用限制，根据引脚图，LED灯连接的是如下定时器的输出引脚
  <img width="884" height="320" alt="image" src="https://github.com/user-attachments/assets/0daa8262-56e8-4226-8022-05ca63bdb4e9" />

  当然即使不是，或者没说也没关系，这个GPIO的复用和重映射关系可以在stm32手册中查得到，大家可以翻阅GPIO复用功能I/O和调试配置章节即可看到。

  在配置GPIO时，需要调成复用推挽模式，还有一个GPIO口需要重映射(这里不严谨，写成了重定义)。即可达成实验目的。


在上文，看似位带操作也就俩三行解决的问题，但是你真想理解地更加深刻，那光会调用那几个函数是绝对不够的。
为什么你会对位带操作有一种似懂非懂的感觉呢？因为你不太了解寄存器，特别是你翻看STM32F10x—中文参考手册的时候，看到寄存器也就是看一眼，或许直接扔给了AI助手帮你总结功能，那些图或许压根都没理解为什么？
真好借助位带操作，我们把寄存器讲的更加深入一点点。
在main分支中，我们谈到了GPIOx各个寄存器中的功能，这里我们就不再赘述。我们直接分析图表，我们先以ODR寄存器为例。
![image](https://github.com/user-attachments/assets/e1f737f9-0c25-42ea-80ca-5d1962b4a7f5)
注意到0到15的位了吗，你有想过为什么不多不少，就要16位呢？他们是用来控制哪些部件的呢？
如果你比较勤快，经常翻看STM32F10x的原理图，你会发现，GPIO的引脚，好像最多也是从0到15欸
![image](https://github.com/user-attachments/assets/356f5da5-99ff-44c6-b077-357997a6cc34)
答案显而易见！每一个位正好对应每一个GPIO的引脚，这就是为什么进行位带操作时，参数需要传入的位序号正好是引脚号的原因！
那么我们再看BSRR寄存器，为什么他们有32位，而其他一部分寄存器只有16位，答案也是显然的。因为BSRR除了写入，还有消除这个功能，需要的位也就多一位，每个引脚都多了一位，那16给引脚那就多了16位。
![image](https://github.com/user-attachments/assets/47b660ef-78c3-40e7-9637-e28707d3178d)
主播主播，要是按你这样说，你看看GPIOx_CRL寄存器，CNFx和MODEx为一组控制一个引脚，那不是才有8组吗？
孩子，你看他的名字里面有个低，那你再往下翻翻是不是还有个高寄存器呀，高寄存器的位带命名，是不是和CRL一模一样呀。而且序号都是接上的。
![image](https://github.com/user-attachments/assets/674b96f7-4d46-4439-8c70-86bf85f20b95)
也就是说，CRL是用来配置0到7引脚的功能，CRH是用来配置8到15引脚的功能。

好，你现在已经对GPIO中寄存器的位有了进一步的理解，你现在再回去看位带操作的代码，是不是没有之前那么膈应了？

讲完这个，我相信你不止只有这一个问题。
如果你细心的话，你应该能想起来我之前提到的GPIO中寄存器的各个功能，除了ODR以外，还有一个寄存器能写入还能消除，那就是BSRR。
欸，那我为什么不能直接对BSRR进行位操作呢，于是你把PBout()和PBin()的ODR改成BSRR，结果灯压根就不亮。
是灯的问题？不，是BSRR写入规则特殊，BSRR需要特定的位模式来设置或者清除端口位，而不是直接赋值。例如：设置PB0为高电平，则BSRR = (1 << 0).不适合直接位带操作。
直接替换会导致操作无效，或者错误赋值。
那么什么时候才适合用位操作呢？
1.简单读写：如ODR、单个标志位（需确认可写）。
2.无副作用：操作不会触发硬件动作（如中断清除）。
3.原子性要求低：无需多比特协同配置。

好了，着一节就到这里，若大家对我的想法有异议或者有其他的想法，欢迎指正和留言。

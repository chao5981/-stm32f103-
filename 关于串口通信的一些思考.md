Q:在利用USART发送字符串或者一定量的数据时，你传入的参数时一个指针，为什么选择指正呢？

W:1.指针允许函数直接操作原始数据缓冲区，避免了不必要的数据拷贝;2.指针+长度参数可以灵活处理任意长度的数据;3.嵌入式系统栈空间有限（通常2-8KB），直接传递大数组会导致栈溢出;4.当使用DMA发送时，必须传递数据缓冲区指针,方便与DMA结合使用;5.指针传递避免了数据拷贝带来的延迟，这对实时系统至关重要.

Q:在配置USART的初始化函数中我调用了这一句USART_ITConfig(DEBUG_USARTx,USART_IT_RXNE,ENABLE)类型的中断。那么既然是这个类型的中断，为什么还需要在中断函数中华，你还用了这个if(USART_GetITStatus(DEBUG_USARTx,USART_IT_RXNE)!=RESET)语句进行判断呢，是不是多此一举了


W：否，USART_ITConfig()这一句的作用是告诉USART外设：当某个中断条件发生时，请你向 NVIC 发一个中断请求。它的作用仅限于启用中断源，我可以多次调用USART_ITConfig()函数，选择不同的中断条件，当对应的中断调节发生时，你都需要像NVIC发送中断请求。但是无论你启用了多少个中断源，它们触发的都是同一个中断函数，比如 USART1_IRQHandler()。所以进去这个中断函数时，就得自己在IRQHandler 里用 USART_GetITStatus() 去判断每个标志位是不是置位了（并且对应的中断源已经打开）。


Q：在利用USART发送数据的几个函数里，你都调用了while(USART_GetFlagStatus(pUSARTx,USART_FLAG_TXE)==RESET);为什么选哟等待TXE置1呢？


W:等待 TXE = 1 是为了确保 “发送数据寄存器” 空了，可以安全地写入下一个字节，否则你可能会“覆盖”掉前一个还没发出去的字节。


Q:那按照你这样说，你编写的中断函数不应该直接用USART_SendData(),而应该使用你自己编写的USART_SendByte()才更加安全才对


W：你说的正确，的确这样更加安全，但由于我用的是回环收发（收了就立刻发），硬件TXE通常已经空，但是在高速大量的数据中，这一点会爆。并且一般地，中断要保证快进快出，尽量不要进行延时处理。使用下一节我们不用USART发送数据，改用更加实用的DMA发送数据。

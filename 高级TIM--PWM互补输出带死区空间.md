  高级TIM所谓高级，就是它除了能实现基本的定时功能以外，还能测量脉宽和频率，以及生成PWM信号。

  这一节我先讲解高级TIM生成PWM信号的基本原理。

  先附上一张高级控制定时器框图
  ![image](https://github.com/user-attachments/assets/88909f36-0a20-449c-979c-4c4cdebf05fc)

  严重怀疑这张图就是防止初学者看懂......

  我按我自己的方式讲出来。

  首先，51单片机玩过吧，还记得51单片机是如何控制引脚输出PWM信号实现呼吸灯的吗？

  不记得了的话我附上我当时写的51单片机的PWM程序

      #include<REGX52.H>
      #include"time.h"
      sbit Motor=P1^0;
      unsigned char Compare;
      void main()
      {
      	unsigned char Speed=0;
      	unsigned char Key=0;
      	time0_Init();
      	while(1)
      	{
      		Key=Keyboard();
      		if(Key)
      		{
      			Speed++;
      			Speed%=4;
      			if(Speed==0)
      			{
      				Compare=0;
      			}
      			if(Speed==1)
      			{
      				Compare=50;
      			}
      			if(Speed==2)
      			{
      				Compare=75;
      			}
      			if(Speed==3)
      			{
      				Compare=100;
      			}
      			
      		}
      		Nixie_Set(1,Speed);
      	}
      }
      
      void Time0()  interrupt 3
      {
      	static unsigned int count1=0,count2=0,count3=0;
      	TL0 = 0x9C;		//设置定时初值
      	TH0 = 0xFF;
      	count1++;
      	count2++;
      	count3++;
      	count3%=100;
      	if(count3<Compare)
      	{
      		Motor=1;
      	}
      	else
      	{
      		Motor=0 ;
      	}
      }


  你看，我是令了P1^0引脚为Motor，作为输出PWM信号的引脚。然后我设定了一个定时器，让定时器每隔一段时间就进入一次中断，让count3++;然后当count3满足一定条件后将P1^0翻转以模拟PWM信号。
  
  所以，51单片机生成PWM的信号的方式是软件手动调整的！而stm32的高级TIM就高级在这里，我完全可以不需要手动，我直接通过硬件就可以生成出PWM信号，而且还更加精准！

  那么，stm32是如何产生PWM信号的呢？

  首先是个定时器就得有个时钟吧，高级TIM和基本TIM的在区别之一是高级TIM有更多的时钟源可以选择。
  图一：
    ![image](https://github.com/user-attachments/assets/4c9755f9-b2ba-47be-a1aa-58aafbfc4cd0)

  图二：
   ![image](https://github.com/user-attachments/assets/e576adc3-2cf5-4412-a4b3-36d672e55590)
  时钟源：

    1.内部时钟CK_INT：对应的是图的最上方，来自芯片内部，等于72MHZ，一般情况下我们都用内部时钟
    2.外部时钟模式1：对应的是图的最左侧的TIMx_CHy(x为其他定时器的型号，y=1,2,3,4),简称TIx(x=1,2,3,4)。
    也就是说，高级定时器的时钟源可以由其他定时器的输出情况来提供。
  

    这图一为外部时钟模式1的工作流程图。其大致的意思是
        1.从TIMx_CHy来的信号可以先经过滤波器进行重新采样
        2.然后选择是上升沿有效还是下降沿有效
        3.然后根据你选择的信号源去选择触发源(你可以理解为让时钟源搭在定时器的时钟上)(例如你选的是CH1作为信号源，则这里应该选择定时器输入 1（TI1FP1）)
        4.最后配置从模式(即配置时钟源的模式，例如这里你选的是外部时钟模式1，那么这里就选择模式为"外部时钟模式1")

    观察可以发现，前俩步是在处理外部信号源，后俩步是在告诉高级TIM我选的信号源是哪一个，时钟模式是哪一个。然后高级TIM就会按照对应的要求去工作。

    3.外部时钟模式2：对应的是图的左上侧的TIMx_ETR，这个引脚信号的来源是其他设备（如传感器、信号发生器、另一片MCU）的输出引脚；
    STM32内部另一个定时器的触发输出（TRGO）；通过外部中断引脚（如EXTI）触发，再路由到ETR等。
    
      相比于外部时钟模式1，其优点在于：
        1.需要将定时器作为高频计数器（如测量高频脉冲、频率计）时，ETR引脚支持更高频率（通常比TI1/TI2引脚更抗干扰）。
        2.在系统需要隔离的独立时钟源时，ETR引脚与TI1/TI2完全独立，避免信号冲突。
        3.在抗干扰要求高的环境，ETR引脚通常具有更好的噪声抑制特性。可配置强滤波（ETRF位域）滤除毛刺。
        4.用于多个定时器需要严格同步（如并联的PWM发生器）。

    图二是外部时钟模式2的工作流程图，其大致的意思是
        1.信号从ETR引脚引进来后，选择是上升沿有效还是下降沿有效
        2.可以选择分频
        3.可以对信号进行滤波
        4.使能计时器即可

      相比外部时钟模式1，外部时钟模式2不用配置选择触发源和信号源，这是它相比于前者更加方便的原因

    4.内部触发输入：也就是图中上侧的ITRx，是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，
    可以实现定时器同步或级联。其中参数的含义为：
        TIM_TS_ITR0：连接到 TIM1/TRC（高级定时器 1 的触发输出或外部触发）。
        TIM_TS_ITR1：连接到 TIM2（通用定时器 2 的触发输出）。
        TIM_TS_ITR2：连接到 TIM3（通用定时器 3 的触发输出）。
        TIM_TS_ITR3：连接到 TIM4（通用定时器 4 的触发输出）。


  好，定时器的脉冲信号(即时钟源)已经有了，知道了谱子，你要弹奏好的话，你还得需要节拍吧，所以定时器还有一个时基。高级定时器的时基和基本定时器差不多，请见功能框图的图三。

  唯一的区别就是多了一个重复计数器。让我们回忆回忆基本TIM，基本TIM是计数器(CNT)数数，数到了自动重载寄存器(ARR)的值，就可以产生一次时间或者中断；在高级定时器中，计数器数到自动重载寄存器的值后看看重复计时器(RCR)的值，如果它没有为0那就使它的值减1，然后重复再数。这就相当于把我基本TIM中断函数中time++，当time等于某个值后才有特定现象出现的这一步的软件配置给融到硬件中了。嘿，所以说它高级不是没有原因的。


  那高级TIM是如何生成PWM信号呢？其实原理和C51没区别，就是在一个周期的一段时间内翻转一个引脚的电平嘛，只不过这个事儿不需要我们自己干了，配置好硬件就可以自己干了，输出PWM的关键硬件是比较寄存器(CCR)

  定时器从0开始累加计数（就像秒表计时）。当计数值 < CCR：输出高电平。当计数值 ≥ CCR：输出低电平。当计数值等于自动重载寄存器(ARR)的值时，计数器(CNT)重置为0，开始下一个周期。这便是其工作原理。


  好，PWM输出就算完成了，但是在实际工程中，经常还会遇到一个问题，在一些外接的设备中，会存在H桥电路(见下图)，如果Q1和Q2同时导通为高电平，那就发生短路直接烧毁电路，那怎么办呢？高级TIM把这件事也考虑进去了，它在每一个输出引脚增加了互补输出引脚。所谓互补，就是和输出引脚输出的电平反过来，那么一个接到Q1，一个接到Q2，这样子俩者的信号永远是不同的，那就从理论上可以避免短路的情况发生了吗。高级TIM中你只需要配置相关结构体成员，无需软件操作，高级TIM就会通过输出引脚和互补输出引脚产生同时的相反的PWM信号，理论上确保不会短路！
  ![image](https://github.com/user-attachments/assets/ecba76cb-481f-4cbb-8cb7-cda1de3988d4)


但是理想很丰满，现实很苦感。你发生变化的时候总需要时间吧，一个电平从高到低，一个电平从低到高，总会有电压相同的吧，那还不是要短路吗？那要怎么办呢？那我在主输出通道从高电平变成低电平的时候，让互补输出延时一段时间，让其在低电平多呆一会，等主输出的电平稳定为低电平后，我再将互补输出引脚调成高电平，这样不就避免了由于同时换路导致可能的短路吗(示意图见下)。在高级TIM中，这个延时有个专业名词，叫做死区。

        普通PWM输出：
        CH1:  |¯¯|__|¯¯|__|  
        CH1N: |__|¯¯|__|¯¯|  

        插入死区后的PWM输出：
        CH1:  |¯¯|____|¯¯|____|  
        CH1N: |__|¯¯¯¯|__|¯¯¯¯|  
                ↑死区 ↑死区  

死区，在互补信号跳变时插入延时，确保上下管在切换时短暂关闭，避免直通。这个同样不需要软件手动控制，硬件自己能控制。这便是高级TIM高级之处！

那么死区的时间要如何确定呢?请按照如下步骤确定死区时间：

      1.功率器件的开关延迟：MOSFET/IGBT的导通/关断时间（查数据手册）：例如：某MOSFET的Turn-On Delay = 50ns，Turn-Off Delay = 70ns。所需死区时间 ≥ (Turn-Off Delay − Turn-On Delay)
      死区时间需覆盖差值（如70ns - 50ns = 20ns）。
      2.驱动电路的传播延迟：驱动芯片（如IR2104）的输入到输出的延迟（通常10~100ns）。

      总死区时间 ≥ 器件延迟 + 驱动延迟。
      3. 安全裕量:额外增加20%~50%的余量，应对温度、电压波动等。

  确定了死区时间，如何配置死区时间？配置死区的时间由三个参数决定，一个定时器的内部时钟CK_CNT的频率。是一个是时基结构体TIM_TimeBaseInitTypeDef中的时钟分频因子TIM_ClockDivision，一个是死区刹车结构体TIM_BDTRInitStructure中的死区时长TIM_DeadTime。

  死区的公式为 DeadTime=TIM_ClockDivision/CK_CNT*TIM_DeadTime.例如：定时器的内部时钟是72MHZ，TIM_ClockDivision选择1分频，则T_dts = 1 / 72MHz ≈ 13.89ns，若TIM_DeadTime=11，则死区时间 = 11 × 13.89ns ≈ 152ns。


这样基本上就没有直通的风险了，但是如果外接的设备过流/过压了，那该怎么办呢？

要是有一个电流/电压传感器，当超过额定阈值时输出一个和平时不一样的电平，stm32芯片引出一个引脚和电流/电压传感器连接，一旦信号发生变化，我就不输出PWM以保护电路。而这就叫刹车(断路)功能。

稍微解释一下为什么停止输出PWM就可以达到保护电路的目的，在电机驱动、开关电源等电路中，通常会使用功率晶体管（如 MOSFET、IGBT 等） 作为开关器件，通过 PWM 信号控制它们的导通和关断，从而实现对负载的功率控制。当电路出现异常情况，比如电机堵转、负载短路等，会导致流过功率器件的电流急剧增大。高级 TIM 的刹车功能可以在检测到异常信号（如来自刹车输入引脚 TIMx_BKIN 的信号）时，迅速停止 PWM 信号的输出。功率器件失去 PWM 驱动信号后，会进入截止状态，从而切断电路中的大电流通路，避免功率器件因长时间过流而损坏。

也就是说，PWM信号控制的是它们的开关开启和闭合情况，而不是作为他们的直接电源去供电。毕竟stm32能承受的电压就5V左右，你输出PWM信号的电平那就最大时5V，5V驱动个蛋的电机啊....

刹车/断路功能：高级TIM的功能之一，在外部设备遇到突发情况可能会损坏电路时强行关闭PWM信号以保护电路。直到过流/过压情况停止后，刹车功能可以软件手动/硬件自动复位，根据配置情况恢复PWM信号的输出。

综上，我们总结一下高级TIM的功能：

    1.定时
    2.输出带死区的安全的PWM信号
    3.在电机出现过流过压时紧急关闭PWM信号进行保护


所以高级TIM为什么高级，这便是原因。


接下来讲解高级TIM的所有结构体

1.TIM_TimeBaseInitTypeDef(时基结构体)

    1.TIM_ClockDivision：时钟分频因子，用于配置死区时长，基本TIM和通用TIM都用不上。
    2. TIM_Period：自动重装载寄存器（ARR）的值，用于设定定时器计数器（CNT）的计数上限。
    3.TIM_Prescaler：预分频器（PSC，Prescaler）的值。分频后时钟频率 = 时钟源频率 / (TIM_Prescaler + 1)。
    4.TIM_CounterMode：定时器的计数模式，用于决定计数器是向上计数、向下计数还是中央对齐（向上 / 向下）计数。基本TIM和通用TIM都用不上。

        这里简要说一下计数模式在PWM信号产生的区别：
            如果是单纯的向上计数，那么生成的PWM信号如图所示：
            ![image](https://github.com/user-attachments/assets/1f0a8c8f-e6ef-475c-920e-e072c1cbacb5)
    
            如果是中央对齐计数，那么生成的PWM信号如图所示：
            ![image](https://github.com/user-attachments/assets/2ec63d9f-36f8-447e-8aa7-78f91621e25d)
    
        所以选择哪种计数方式看设备对PWM信号波形的需求，当然大部分情况下都是向上计数。

    5.TIM_RepetitionCounter：重复计数器的值，仅在高级控制定时器中有效。它用于在产生更新事件之前，指定重复计数器重复计数的次数。
    主要用于生成高级 PWM 波形，以及在需要更精确控制更新事件触发时机的场合。当然一般情况下，输出生成PWM信号时，我们设置为0。

2.TIM_OCInitTypeDef(输出和互补输出结构体)

    1.TIM_OCMode：输出比较模式，用于指定定时器输出比较通道的工作模式
    2.TIM_OutputState：主输出使能状态，用于使能或禁止定时器输出比较通道的主输出。
    3.TIM_OutputNState：互补输出使能状态，用于使能或禁止互补输出通道。
    4.TIM_Pulse：脉冲值，即输出比较的比较值。在 PWM 模式下，该值决定了 PWM 波形的占空比。
    Pulse的取值范围为 0 到 TIM_Period（即自动重载寄存器ARR的值）。具体规则如下：
    占空比=Pulse/ARR
    例如：在 PWM 模式 1 下，若定时器周期为 100，TIM_Pulse 设置为 30，则占空比为 30%。
    
    5.TIM_OCPolarity：主输出极性，用于定义当输出比较通道有效时，输出信号的电平状态。一般设置为高电平有效--high
    6.TIM_OCNPolarity：互补输出极性，仅在使用互补输出功能时有效，用于定义互补输出通道有效时的电平状态。一般设置为高电平有效--high
    7. TIM_OCIdleState:主输出在空闲状态下的电平状态，空闲状态是指当产生刹车信号或进入待机模式等特定情况下输出的电平。一般设置为低电平--Reset
    8. TIM_OCNIdleState:互补输出在空闲状态下的电平状态，同样是在产生刹车信号或进入待机模式等特定情况下互补输出通道的电平。一般设置为低电平--Reset

注意,输出结构体的初始化和时基结构体的初始化不同.其初始化函数为TIM_OCxInit().

3.TIM_BDTRInitStructure(刹车和死区结构体)

    1.TIM_OSSRState：运行模式（非刹车时）下的输出状态
    注意：这里参数ENABLE表示正常输出，DISABLE表示关闭输出。

    2.TIM_OSSIState：空闲模式（刹车时）下的输出状态
    注意：这里参数ENABLE表示强制安全电平，DISABLE表示关闭输出。

    3.TIM_BreakPolarity：设置刹车输入信号（BKIN引脚）的有效极性。一般选择高电平有效。

    4.TIM_LOCKLevel：配置寄存器写保护级别，防止误修改配置。Level_1是最低保护，Level_3是最高保护
    5.TIM_Break：使能或禁用刹车功能。
    6.TIM_DeadTime：设置死区时间长度
    7.TIM_AutomaticOutput：是否允许硬件自动恢复PWM输出（刹车解除后）


上述就是用高级TIM输出PWM信号会用到的结构体，后面还有一个捕获寄存器的结构体下一节再讲吧。

想必大家还有疑惑的点是PWM信号的占空比，PWM周期应该选什么数好。

这个我这里无能为例，因为每一个不同的电机或者外接设备要求的PWM信号肯定是有区别的，所以我没法告诉大家一个能完美移植的PWM信号的参数，我只能告诉大家设置PWM信号的原理。

首先如何确定PWM周期，我这里给大家汇总一下吧

PWM周期由定时器的时基产生，PWM本质上是一个个事件发生组成在一块的结果，而产生一次事件是计数器(CNT)，定时器内部频率CK_CNT和自动重载寄存器(ARR)共同决定的。

计算公式为：PWM周期=(ARR+1)/CK_CNT,而CK_CNT=CK_INT/(PSC+1);代入得：PWM周期=(ARR+1)*(PSC+1)/CK_INT。

    例如：CK_INT = 72MHz（STM32F1默认值）。PSC = 71（分频后CK_CNT = 72MHz / (71+1) = 1MHz）。ARR = 999（计数器从0计数到999）。
    
    那么结果为：PWM周期=(999+1)/1MHZ=1000us(1MHz = 10⁶ Hz)

占空比就根据外部设备要求的设置即可。

        





  
        

    

  

  

  高级TIM所谓高级，就是它除了能实现基本的定时功能以外，还能测量脉宽和频率，以及生成PWM信号。

  这一节我先讲解高级TIM生成PWM信号的基本原理。

  先附上一张高级控制定时器框图
  ![image](https://github.com/user-attachments/assets/88909f36-0a20-449c-979c-4c4cdebf05fc)

  严重怀疑这张图就是防止初学者看懂......

  我按我自己的方式讲出来。

  首先，51单片机玩过吧，还记得51单片机是如何控制引脚输出PWM信号实现呼吸灯的吗？

  不记得了的话我附上我当时写的51单片机的PWM程序

      #include<REGX52.H>
      #include"time.h"
      sbit Motor=P1^0;
      unsigned char Compare;
      void main()
      {
      	unsigned char Speed=0;
      	unsigned char Key=0;
      	time0_Init();
      	while(1)
      	{
      		Key=Keyboard();
      		if(Key)
      		{
      			Speed++;
      			Speed%=4;
      			if(Speed==0)
      			{
      				Compare=0;
      			}
      			if(Speed==1)
      			{
      				Compare=50;
      			}
      			if(Speed==2)
      			{
      				Compare=75;
      			}
      			if(Speed==3)
      			{
      				Compare=100;
      			}
      			
      		}
      		Nixie_Set(1,Speed);
      	}
      }
      
      void Time0()  interrupt 3
      {
      	static unsigned int count1=0,count2=0,count3=0;
      	TL0 = 0x9C;		//设置定时初值
      	TH0 = 0xFF;
      	count1++;
      	count2++;
      	count3++;
      	count3%=100;
      	if(count3<Compare)
      	{
      		Motor=1;
      	}
      	else
      	{
      		Motor=0 ;
      	}
      }


  你看，我是令了P1^0引脚为Motor，作为输出PWM信号的引脚。然后我设定了一个定时器，让定时器每隔一段时间就进入一次中断，让count3++;然后当count3满足一定条件后将P1^0翻转以模拟PWM信号。
  
  所以，51单片机生成PWM的信号的方式是软件手动调整的！而stm32的高级TIM就高级在这里，我完全可以不需要手动，我直接通过硬件就可以生成出PWM信号，而且还更加精准！

  那么，stm32是如何产生PWM信号的呢？

  首先是个定时器就得有个时钟吧，高级TIM和基本TIM的在区别之一是高级TIM有更多的时钟源可以选择。

  时钟源：

    1.内部时钟CK_INT：对应的是图的最上方，来自芯片内部，等于72MHZ，一般情况下我们都用内部时钟
    2.外部时钟模式1：对应的是图的最左侧的TIMx_CHy(x为其他定时器的型号，y=1,2,3,4),简称TIx(x=1,2,3,4)。
    也就是说，高级定时器的时钟源可以由其他定时器的输出情况来提供。
    ![image](https://github.com/user-attachments/assets/4c9755f9-b2ba-47be-a1aa-58aafbfc4cd0)

    这幅图为外部时钟模式1的工作流程图。其大致的意思是
        1.从TIMx_CHy来的信号可以先经过滤波器进行重新采样
        2.然后选择是上升沿有效还是下降沿有效
        3.然后根据你选择的信号源去选择触发源(你可以理解为让时钟源搭在定时器的时钟上)(例如你选的是CH1作为信号源，则这里应该选择定时器输入 1（TI1FP1）)
        4.最后配置从模式(即配置时钟源的模式，例如这里你选的是外部时钟模式1，那么这里就选择模式为"外部时钟模式1")

    观察可以发现，前俩步是在处理外部信号源，后俩步是在告诉高级TIM我选的信号源是哪一个，时钟模式是哪一个。然后高级TIM就会按照对应的要求去工作。

    3.外部时钟模式2：对应的是图的左上侧的TIMx_ETR，这个引脚信号的来源是其他设备（如传感器、信号发生器、另一片MCU）的输出引脚；
    STM32内部另一个定时器的触发输出（TRGO）；通过外部中断引脚（如EXTI）触发，再路由到ETR等。
    
      相比于外部时钟模式1，其优点在于：
        1.需要将定时器作为高频计数器（如测量高频脉冲、频率计）时，ETR引脚支持更高频率（通常比TI1/TI2引脚更抗干扰）。
        2.在系统需要隔离的独立时钟源时，ETR引脚与TI1/TI2完全独立，避免信号冲突。
        3.在抗干扰要求高的环境，ETR引脚通常具有更好的噪声抑制特性。可配置强滤波（ETRF位域）滤除毛刺。
        4.用于多个定时器需要严格同步（如并联的PWM发生器）。
      ![image](https://github.com/user-attachments/assets/e576adc3-2cf5-4412-a4b3-36d672e55590)

    这是外部时钟模式2的工作流程图，其大致的意思是
        1.信号从ETR引脚引进来后，选择是上升沿有效还是下降沿有效
        2.可以选择分频
        3.可以对信号进行滤波
        4.使能计时器即可

      相比外部时钟模式1，外部时钟模式2不用配置选择触发源和信号源，这是它相比于前者更加方便的原因

    4.内部触发输入：也就是图中上侧的ITRx，是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，
    可以实现定时器同步或级联。比较少用，了解即可。


  好，定时器的脉冲信号(即时钟源)已经有了，知道了谱子，你要弹奏好的话，你还得需要节拍吧，所以定时器还有一个时基。高级定时器的时基和基本定时器差不多，请见功能框图的图三。

  唯一的区别就是多了一个重复计数器。让我们回忆回忆基本TIM，基本TIM是计数器(CNT)数数，数到了自动重载寄存器(ARR)的值，就可以产生一次时间或者中断；在高级定时器中，计数器数到自动重载寄存器的值后看看重复计时器(RCR)的值，如果它没有为0那就使它的值减1，然后重复再数。这就相当于把我基本TIM中断函数中time++，当time等于某个值后才有特定现象出现的这一步的软件配置给融到硬件中了。嘿，所以说它高级不是没有原因的。


  那高级TIM是如何生成PWM信号呢？其实原理和C51没区别，就是在一个周期的一段时间内翻转一个引脚的电平嘛，只不过这个事儿不需要我们自己干了，配置好硬件就可以自己干了，输出PWM的关键硬件是比较寄存器(CCR)

  定时器从0开始累加计数（就像秒表计时）。当计数值 < CCR：输出高电平。当计数值 ≥ CCR：输出低电平。当计数值等于自动重载寄存器(ARR)的值时，计数器(CNT)重置为0，开始下一个周期。这便是其工作原理。

  注意，这个流程可不经过重复定时器(RCR)，看回最上边的功能框架图，计数器(CNT)是直接搭了线到比较寄存器(CRR)了(图上的大箭头)


  好，PWM输出就算完成了，但是在实际工程中，经常还会遇到一个问题，在一些外接的设备中，会存在H桥电路(见下图)，如果Q1和Q2同时导通为高电平，那就发生短路直接烧毁电路，那怎么办呢？高级TIM把这件事也考虑进去了，它在每一个输出引脚增加了互补输出引脚。所谓互补，就是和输出引脚输出的电平反过来，那么一个接到Q1，一个接到Q2，这样子俩者的信号永远是不同的，那就从理论上可以避免短路的情况发生了吗。高级TIM中你只需要配置相关结构体成员，无需软件操作，高级TIM就会通过输出引脚和互补输出引脚产生同时的相反的PWM信号，理论上确保不会短路！
  ![image](https://github.com/user-attachments/assets/ecba76cb-481f-4cbb-8cb7-cda1de3988d4)


但是理想很丰满，现实很苦感。你发生变化的时候总需要时间吧，一个电平从高到低，一个电平从低到高，总会有电压相同的吧，那还不是要短路吗？那要怎么办呢？那我在主输出通道从高电平变成低电平的时候，让互补输出延时一段时间，让其在低电平多呆一会，等主输出的电平稳定为低电平后，我再将互补输出引脚调成高电平，这样不就避免了由于同时换路导致可能的短路吗(示意图见下)。在高级TIM中，这个延时有个专业名词，叫做死区。

        普通PWM输出：
        CH1:  |¯¯|__|¯¯|__|  
        CH1N: |__|¯¯|__|¯¯|  

        插入死区后的PWM输出：
        CH1:  |¯¯|____|¯¯|____|  
        CH1N: |__|¯¯¯¯|__|¯¯¯¯|  
                ↑死区 ↑死区  

死区，在互补信号跳变时插入延时，确保上下管在切换时短暂关闭，避免直通。这个同样不需要软件手动控制，硬件自己能控制。这便是高级TIM高级之处！

那么死区的时间要如何确定呢?请按照如下步骤确定死区时间：

      1.功率器件的开关延迟：MOSFET/IGBT的导通/关断时间（查数据手册）：例如：某MOSFET的Turn-On Delay = 50ns，Turn-Off Delay = 70ns。所需死区时间 ≥ (Turn-Off Delay − Turn-On Delay)
      死区时间需覆盖差值（如70ns - 50ns = 20ns）。
      2.驱动电路的传播延迟：驱动芯片（如IR2104）的输入到输出的延迟（通常10~100ns）。

      总死区时间 ≥ 器件延迟 + 驱动延迟。
      3. 安全裕量:额外增加20%~50%的余量，应对温度、电压波动等。

  确定了死区时间，如何配置死区时间？配置死区的时间由三个参数决定，一个是一个是时基结构体TIM_TimeBaseInitTypeDef中的时钟分频因子TIM_ClockDivision，一个是死区刹车结构体TIM_BDTRInitStructure中的死区时长TIM_DeadTime。


这样基本上就没有直通的风险了，但是如果外接的设备过流/过压了，那该怎么办呢？

要是有一个电流/电压传感器，当超过额定阈值时输出一个和平时不一样的电平，stm32芯片引出一个引脚和电流/电压传感器连接，一旦信号发生变化，我就不输出PWM以保护电路。而这就叫刹车(断路)功能。

稍微解释一下为什么停止输出PWM就可以达到保护电路的目的，在电机驱动、开关电源等电路中，通常会使用功率晶体管（如 MOSFET、IGBT 等） 作为开关器件，通过 PWM 信号控制它们的导通和关断，从而实现对负载的功率控制。当电路出现异常情况，比如电机堵转、负载短路等，会导致流过功率器件的电流急剧增大。高级 TIM 的刹车功能可以在检测到异常信号（如来自刹车输入引脚 TIMx_BKIN 的信号）时，迅速停止 PWM 信号的输出。功率器件失去 PWM 驱动信号后，会进入截止状态，从而切断电路中的大电流通路，避免功率器件因长时间过流而损坏。

也就是说，PWM信号控制的是它们的开关开启和闭合情况，而不是作为他们的直接电源去供电。毕竟stm32能承受的电压就5V左右，你输出PWM信号的电平那就最大时5V，5V驱动个蛋的电机啊....

刹车/断路功能：高级TIM的功能之一，在外部设备遇到突发情况可能会损坏电路时强行关闭PWM信号以保护电路。直到过流/过压情况停止后，刹车功能可以软件手动/硬件自动复位，根据配置情况恢复PWM信号的输出。

综上，我们总结一下高级TIM的功能：

    1.定时
    2.输出带死区的安全的PWM信号
    3.在电机出现过流过压时紧急关闭PWM信号进行保护


所以高级TIM为什么高级，这便是原因。


接下来讲解高级TIM的所有结构体

1.TIM_TimeBaseInitTypeDef(时基结构体)

    1.





  
        

    

  

  

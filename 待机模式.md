  待机模式就在降低功耗上更猛了，其具体特性见下图：

  <img width="944" height="314" alt="image" src="https://github.com/user-attachments/assets/6ee92a02-c786-448e-b816-4f0bca6f8abc" />

  其进入方式比前俩者更加地严苛。要求内核寄存器的SLEEPDEEP位为1，PWR_CR寄存器中的PDDS位为1，PWR_CR中的WUF位为0，再调用WFI/WFE指令才能进入待机模式。当然这个都被封装在标准库中的

  唤醒方式更加少，只有WKUP引脚的上升沿(大部分stm32默认为PA0，但是我在参考手册没找到)，PTC闹钟等比外部中断更加严苛的方式唤醒。

  在待机状态时，内核，外设全部停止工作，内核寄存器，内存的数据全部丢失，除了上述少部分没有引脚仍然可以工作，其他I/O口全在高阻态(停止工作)

  为什么会这样呢。因为无论时睡眠模式还是停止模式，他们只是关闭了时钟，并没有断电，而除了关闭所有时钟，待机模式直接把主供电域(1.8V区域的电源)关闭了，所有外设全部掉电，他们连最基本的硬件输出输入都停止了。

  也正是因为如此，所以内核寄存器，内存的数据全部丢失。若从待机模式唤醒了，那么程序就从头开始工作了，而不是从进入待机状态那个地方开始工作。

  要进入待机模式，必须开启PWR时钟(其实前面的待机模式和睡眠模式无需开启PWR时钟，但是开启了无妨，为了怕忘记，因此直接打开);在主函数中调用PWR_WakeUpPinCmd()函数开启WKUP引脚唤醒(否则WKUP引脚无法唤醒)，如果你不要WKUP引脚唤醒的
话可以不调用;最后调用PWR_EnterSTANDBYMode()即可进入待机模式。

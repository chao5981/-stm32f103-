  STM32 有两个看门狗，一个是独立看门狗另外一个是窗口看门狗，独立看门狗用通俗一点的话来解释就是一个 12 位的递减计数器，当计数器的值从某个值一直减到 0 的时候，系统就会产生一个复位信号，即 IWDG_RESET。如果在计数没减到 0 之前，刷新了计数器的值的话，那
么就不会产生复位信号，这个动作就是我们经常说的喂狗。

  看门狗功能由 VDD 电压域供电，在停止模式和待机模式下仍能工作。

  下面是IWDG功能框架示意图：
  ![image](https://github.com/user-attachments/assets/20177289-3ea0-45e6-9396-8a45b99dc100)


  简单讲解一下

  首先IWDG的时钟源始终为LSI，可以配置预分频器对时钟源进行分频

  然后你需要填入重装载寄存器的值，然后需要把重装载寄存器的值放入到计数器中计数。

  如果减到了0，那么它会直接发出IWDG复位，让程序重新开始。

  如果你再减到0之前再次把重装载寄存器的值放入到计数器中，那么计数器从头开始重新计数，就不会产生复位信号，程序正常运行。

  我个人感觉它就是一个基本TIM的PLUS版，不过就是连着一个和不同于主流的时钟源，这样可以有效防止时钟振荡引起的程序跑飞；然后基本TIM的计数器数完产生的中断/事件型号换成了IWDG复位信号。仅此而已。

  IWDG的函数没有几个，也很好懂，所以这里不多讲解。

  值得一提的是IWDG的检测复位状态函数是在RCC里面的，没有专门的检测复位状态的函数。

  IWDG产生IWDG复位信号的时间计算公式为：T=40/Prescaler(预分频器的值)*reload(重装载寄存器的值)

  我这里的编写逻辑是：程序进入循环后，每隔5s需要按下Key1键模拟喂狗，如果没有按时喂狗，那么程序复位，会亮红灯。

  这里之所以不整一个正常的程序而模拟的原因是，程序跑飞还是有点困难的，现象不容易观测啊...

  while 部分是我们在项目中具体需要写的代码，这部分的程序可以用独立看门狗来监控，如果我们知道这部分代码的执行时间，比如是 500ms，那么我们可以设置独立看门狗的溢出时间是 510ms，比 500ms 多一点，如果要被监控的程序没有跑飞正常执行的话，那么执行完毕之后就会执行喂狗的程序，如果程序跑飞了那程序就会超时，到达不了喂狗的程序，此时就会产生系统复位，但是也不排除程序跑飞了又跑回来了，刚好喂狗了，歪打正着。所以要想更精确的监控程序，可以使用窗口看门狗，窗口看门狗规定必须在规定的窗口时间内喂狗，早了不行，晚了也不行。

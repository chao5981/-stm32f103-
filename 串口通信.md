在串口通信的参考手册里面，有一张原理图，吓退不少stm32的初学者。毕竟它和C8051的串口通信相比确实过于恐怖了。

这是C51的串口通信原理图
![49cb96b6bb4b8816d0d956f5e9e9509](https://github.com/user-attachments/assets/eb065ed8-88c8-4847-8212-40dfc6b5c51c)

这是stm32f103的串口通信原理图
![fa4b4842456c5ed671ca6df52feffa2](https://github.com/user-attachments/assets/9943e792-33f9-4ba3-ac86-cbc443b6e3cb)

其实我们仔细观察不难发现，C51的串口通信基本上也就是stm32中串口通信原理图的黑框框那一部分。stm32原理图中的剩余部分，本质上就是一堆寄存器。

这里我给大家介绍一下我们会用到的部分，不常用的我会略讲或直接略过。大家可以先跳过这一部分，先看明白USART如何配置才能工作，再返回来看这里，以加深印象。

一.原理图的介绍
1.TX（Transmit）：数据发送引脚，用于将 USART 发送移位寄存器中的数据发送出去。

2.RX（Receive）：数据接收引脚 ，用于接收外部串行数据。

3.nRTS（Request To Send）：n 表示低电平有效。如果使能 RTS 流控制，当USART接收器准备好接收新数据时就会将 nRTS 变成低电平；当接收寄存器已满时，nRTS 将被设置为高电平。该引脚只适用于硬件流控制。

4.nCTS（Clear To Send）：n 表示低电平有效。如果使能 CTS 流控制，发送器在发送下一帧数据之前会检测 nCTS 引脚，如果为低电平，表示可以发送数据，如果为高电平则在发送完
当前数据帧之后停止发送。该引脚只适用于硬件流控制。

5.扩展3/4:硬件流控制：一种通过硬件信号线来管理数据传输速率、防止数据溢出丢失的机制。也就是说，TX/RX正常发送和接收数据，当你开启了硬件流控制，若有一方"忙不过来时"，会操作RTS/CTS，告诉对方你先别发了，让我缓缓。等处理完这边的数据后，在操作RTS/CTS，告诉对方可以继续发送数据了。

6.IRDA_OUT：红外数据输出引脚，用于在红外通信模式（IrDA）下发送红外编码数据。

7.IRDA_IN：红外数据输入引脚，用于在红外通信模式下接收红外编码数据。

8.SW_RX：用于智能卡通信时接收数据，在智能卡模式下作为接收引脚使用。

9.USART_SR(状态寄存器)。根据原理图，你会发现它一整个寄存器都连接着"USART中断控制"，那么它必然和中断紧密相连。

①.CTS: CTS 标志 (CTS flag).如果设置了CTSE位，当nCTS输入变化状态时，该位被硬件置高。由软件将其清零。如果USART_CR3中的CTSIE为’1’，则产生中断。

②.TXE:发送数据寄存器空 (Transmit data register empty),当TDR寄存器中的数据被硬件转移到移位寄存器的时候，该位被硬件置位。如果USART_CR1寄存器中的TXEIE为1，则产生中断。对USART_DR的写操作，将该位清零。

③.TC：发送完成 (Transmission complete) .当包含有数据的一帧发送完成后，并且TXE=1时，由硬件将该位置’1’。如果USART_CR1中的TCIE为’1’，则产生中断。由软件序列清除该位(先读USART_SR，然后写入USART_DR)。TC位也可以通过写入’0’来清除，只有在多缓存通讯中才推荐这种清除程序。

④.RXNE：读数据寄存器非空 (Read data register not empty) .当RDR移位寄存器中的数据被转移到USART_DR寄存器中，该位被硬件置位。如果USART_CR1寄存器中的RXNEIE为1，则产生中断。对USART_DR的读操作可以将该位清零。RXNE位也可以通过写入0来清除，只有在多缓存通讯中才推荐这种清除程序。

⑥.除了LBD和IDLE以外(不常用)，其他的都是出现了一些报错才会发生，并且很少用，在此不多赘述。

10.USART_DR(数据寄存器)：包含了发送或接收的数据。由于它是由两个寄存器组成的，一个给发送用(TDR)，一个给接收用(RDR)，该寄存器兼具读和写的功能。

11.USART_BRR(波特比率寄存器):设置波特率。

12.USART_CR1(控制寄存器1)：最关键的寄存器，控制着接收器控制，发送器控制，唤醒单元和USART中断控制。

①.M：字长 (Word length)该位定义了数据字的长度，由软件对其设置和清零

②.WAKE：唤醒的方法 (Wakeup method)这位决定了把USART唤醒的方法，由软件对该位设置和清零。

③.PCE：检验控制使能 (Parity control enable)，选择是否进行校验。

④.PS：校验选择 (Parity selection) 当校验控制(PCE)使能后，该位用来选择是采用偶校验还是奇校验。

⑤.选择发送中断的情况：PEIE：PE中断使能 (PE interrupt enable);TXEIE：发送缓冲区空中断使能 (TXE interrupt enable);TCIE：发送完成中断使能 (Transmission complete interrupt enable);RXNEIE：接收缓冲区非空中断使能 (RXNE interrupt enable);IDLEIE：IDLE中断使能 (IDLE interrupt enable).

⑥.TE：发送使能 (Transmitter enable),该位使能发送器

⑦.RE：接收使能 (Receiver enable)

⑧.其他不常用，学有余力自行了解。

13.USART_CR2(控制寄存器2):关键控制时钟和停止位

①.STOP：停止位 (STOP bits),这2位用来设置停止位的位数

②.CLKEN：时钟使能 (Clock enable),该位用来使能CK引脚

③.其余不常用

14.USART_CR3(控制寄存器3)：控制CTS/RTS，红外串口通信，DMA。DMA最常用。

①.CTSIE：CTS中断使能 (CTS interrupt enable)

②.CTSE：CTS使能 (CTS enable)

③.RTSE：RTS使能 (RTS enable)

④.DMAT：DMA使能发送 (DMA enable transmitter)

⑤.DMAR: DMA使能接收 (DMA enable receiver)

⑥.HDSEL：半双工选择 (Half-duplex selection),选择单线半双工模式

⑦.IREN：红外模式使能 (IrDA mode enable),该位由软件设置或清除。

⑧.IRLP：红外低功耗 (IrDA low-power),该位用来选择普通模式还是低功耗红外模式

⑨.SCEN: 智能卡模式使能 (Smartcard mode enable),注：UART4和UART5上不存在这一位。

⑩.NACK：智能卡NACK使能 (Smartcard NACK enable),注：UART4和UART5上不存在这一位。


由此，这张USART的原理图就介绍完毕。在此处整一下队，我来讲讲USART大致的的工作流程。

首先，要发送的数据将会存储在发送数据寄存器(TDR)中，当其中一字节的数据被硬件转移到移位寄存器的时候，TXE被硬件置1，代表着发送数据寄存器(TDR)没东西了，告知可以继续写字节到发送数据寄存器(TDR)中，写入过后TXE被清0，如此循环;
接着发送数据，发送数据完成且TXE=1时,TE位会被置1;
最后，在正常条件下，发送完成的数据会到接收移位寄存器中，当RDR移位寄存器中的数据被转移到接收数据寄存器(RDR)中，RXNE会被硬件置位。告知这里有数据，可以读取了，读取到缓存区后RXNE被清0，如此循环.

接下来我们进行程序编写的介绍。

二.程序的编写

目的:编写一个关于串口通信的函数，让其接收到电脑端的数据，并且能把手动传输数据给电脑端，或者把电脑端的数据回传到电脑端。

这里我们正常的用USART去接收来自电脑的数据，然后利用中断函数去传输电脑给我们发送的数据。

为什么要用中断函数呢？我不能把电脑传给我的数据先存起来然后在其他函数里面回传吗？当然可以，但是这样第一会占用CPU，第二是如果是高速大量的数据传播，缓冲区的内存要开辟很大，担心爆栈。

因此，我们需要利用外设NVIC对USART的中断进行配置。

1.编写NVIC配置USART的初始化函数
![image](https://github.com/user-attachments/assets/92ff2ee8-153b-4132-8656-18fc6eebc7b4)

定义一个结构体并按照里面的参数进行配置，最后初始化它。

这里值得一提的是，根据行业"约定俗称"的标准，我们习惯将USART选择2分组;抢占优先级和子优先级设置为1;这样能保证USART处于一种高于按键等的中断但是低于一些关键的中断


2.配置USART的初始化函数
![image](https://github.com/user-attachments/assets/fb8540bc-0d39-4801-9055-ba1ee07faa43)
①.定义一个USART结构体

②.开启时钟，注意，USART1是在APB2时钟总线上，其余的挂在APB1总线上，调用的相关函数也不一样。

③.初始化这个结构体

④.调用NVIC函数

⑤.选择并开启USART的中断类型，这里我们选择一个数据从RDR移位寄存器中的数据被转移到接收数据寄存器(RDR)时就产生一次中断。其余的中断方式我个人觉得不行，因为前面多了一个字节和后面少了一个字节。会导致数据乱码和丢失。
注意：我可以多次调用这个函数以开启多个中断类型。
![image](https://github.com/user-attachments/assets/cfc22c93-f7c3-48db-837e-0f1a2a2c6fb3)


⑥.使能USART
![image](https://github.com/user-attachments/assets/5ccd7e2a-55bf-4413-999c-6b4b5d976b79)

在这里我介绍一下USART结构体中各个成员的含义：

USART_BaudRate:选择USART的波特率

USART_HardwareFlowControl：是否选择硬件流控制，这里我们没有用到，选择无

USART_Mode:USART的传输模式，我们这里是选择了全双工模式

USART_Parity：USART的校验符，我们这里没有使用，选择无

USART_StopBits:USART的停止符，这里我们选择以1为停止符

USART_WordLength:USART的字长，一般地，我们传输数据都是用的8位，也就是8字节。

3.初始化USART相关的GPIO引脚，分别是USARTx的TX和RX引脚。TX引脚为推挽复用输出，RX为浮空输入模式。其他的我就不多赘述。

通过上述几个函数确实可以实现接收数据和发送数据了，因为在HAL库只是提供了发送一个字节的数据USART_SendData()和接收一个字节的数据USART_ReceiveData();所以，我们还要编写发送数据的函数。但是在你调试程序的时候，发送一个字节的话无法快速定位时哪里出了问题。因此我们还需要自己编写一个发送字符串的函数。当然，这个难度也不大，大家自行看着我的代码copy一下即可。

既然有了USART_SendData()和USART_ReceiveData()函数，那我们就可以编写数据回传的函数了，这里我们直接用这俩个函数，尽量不用到缓冲区，节省栈的空间。编写起来也很简单，大家可以看我的中断函数借鉴一下即可

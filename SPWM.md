  SPWM,即脉冲宽度按正弦规律变化而和正弦波等效的PWM波形。简单来说就是电压随着时间变化而以正弦，或者各种任意波形变化的波形，常见的波形如图所示：

  <img width="933" height="447" alt="image" src="https://github.com/user-attachments/assets/f9e83604-9d72-449a-8076-24d5ac8c47b7" />

  <img width="1074" height="557" alt="image" src="https://github.com/user-attachments/assets/b7d3a8f0-0fa8-42eb-813e-36dd7ea37b6e" />

  这时候你肯定又疑问，PWM波不输出就是0V，一旦输出就是3.3V，输出的时候不是恒定的电压吗，SPWM波这电压也不恒定啊，它呈周期性变化啊，这怎么能通过对外输出恒定电压PWM波生成呢？

  你要这样理解那肯定会出问题，我们得借用一下物理等效的思想去理解。

  让我们回到最基础的质点运动学，现在有俩辆小车，A做匀速直线运动，B做匀变速直线运动，最后在相同的时间内走了相同的路程。我现在告诉你A的速度和时间，你能不能求出B走的路程。

  这里我们运用了等效的思想。用一个恒定不变的值代替变化的值。

  SPWM波和PWM波也是如此。这里图的电压不要理解为瞬时的电压，而要理解为：平均电压。

  那我们再对这个曲线用微分的思想，把他分成一小块一小块区间。每一小块区间的平均电压不同。

  我们再把目光局限于SPWM波的一块小区间内，SPWM波那一小块的平均电压就用一段时间内的PWM波输出的平均电压去表示。思路的图示如下：

  ![f217848db407207b73f85f6e3af4c87](https://github.com/user-attachments/assets/947fa1e8-da91-4384-bb73-825f60175fde)

  好，那么我们就可以通过调整PWM的占空比，从而输出再不同的时间间隔内不同的平均电压的值，再由很多段这样的小块组成SPWM信号。

  现在，我们把不同的平均电压输出小块的时长设为PERIOD_CLASS。一共有POINT_NUM个时间间隔。由于SPWM波中不同时间间隔内的平均电压不同，所有PWM波的占空比固然不同，我们把占空比所有的值放在一个indexWave[]数组内。其占空比的个数
就为POINT_NUM。

  好，理论上，我们只需要尽可能地把SPWM波分成足够多的时间间隔，也就是扩大POINT_NUM的值，就可以完美地拟合出平滑的SPWM信号。于是你让python脚本帮你生成超级多的占空比的值，扔到indexWave数组中，然后配置GPIO,TIM,NVIC中断，烧
录程序。

 你这程序大概率就不出意外地卡死了。

 你遗漏了一个最关键的问题，栈！没错，一般地，芯片的栈也就2-4KB，你要是尽可能多的数据，那就直接爆栈了,程序无法运行。

 理想很丰满，现实很骨感啊，要是POINT_NUM数值太小，那么这个SPWM就不光滑了，一段一段的；要是POINT_NUM太大，那你的栈空间就会非常紧张。

 是时候做出取舍了。聪明的工程师想到了牺牲SPWM波的平均电压大小使得生成的SPWM波更加平缓。

 比如，A时间间隔内的平均电压为4V，B时间间隔内的平均电压为10V，假设AB俩个时间间隔相邻，那么从A到B的过程中，平均电压跃变地很大，SPWM波不是很光滑，是吧。

 那如果，我把A时间间隔内的平均电压从4V降到2V，B时间间隔内的平均电压从10V降到5V，各打50大板，这样是不是就比上面拟合出来的SPWM波更加平缓？

 要是这样想的话，那就有俩种方式去实现成比例降低平均电压的方法。

 第一种：成比例地改变PWM波的占空比。这个细想很有道理，代码最简单。但是也最难实现。你要把占空比同时除以一个倍数后，保证这个indexWave数组内的所有元素必须为整数(比较寄存器CCR必须为整数)，要是我不是折50%，而是折30%呢

 所以这个不现实，那么就是第二种方法：定义一个不断循环地计数变量amplitude_cnt，让其在一定范围内不断地自增，当它没到达一定值时，比较寄存器恒定为0不输出电压。当它到达一定值后，才往比较寄存器中存入预定的占空比的值，让其输出
PWM信号，这样SPWM一段时间间隔内的平均电压不久下来了吗。

 思路如下图所示：

![7eb63bbb77bb7a8b0e3f53485560c02](https://github.com/user-attachments/assets/35ffe478-83cd-4c9e-8fcb-9957ac667253)

  生成SPWM波的原理就这么多，其实具体实现并不复杂。配置GPIO,TIM,配置NVIC中断。TIM计数完一次进入中断。SPWM的实现主要集中于中断服务的函数逻辑上。逻辑就是让amplitude_cnt，如果自增到顶后清0，在这个过程中if语句持续判断是否
达到预定值，到了就往CCR寄存器中写值，没达到那比较寄存器的值就是0.在amplitude_cnt自增到顶后，让period_cnt自增(控制单个点循环的次数)，当其大于PERIOD_CLASS，就清0并让一个指针 pwm_index指向indexWave[]下一个元素。


  至此，大功已成，下面讲解一下注意事项

    1.TIM_Period：与PWM表中数值范围一致
    2.TIM_Prescaler：越小越好，可减轻闪烁现象

  在呼吸灯中，AMPLITUDE_CLASS我设定为256，因为电压和LED通道的亮度值相关，因此分256个等级，对应RGB888格式各通道的颜色等级


  如何计算SPWM的周期，计算公式如下：

  #定时器update事件周期
	t_timer = t_pclk*TIMER_TIM_Prescaler*TIMER_TIM_Period

   #每个PWM点的时间
	T_Point = t_timer * Σ(POINT_NUM*period_class)

  #整个呼吸周期
  T_Up_Down_Cycle = T_Point * POINT_NUM*PERIOD_CLASS


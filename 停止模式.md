  上一节讲解了睡眠模式，这一节将是功率更低的模式--停止模式。

  停止模式的特性见表格：
  <img width="921" height="543" alt="image" src="https://github.com/user-attachments/assets/64c45061-9ec9-4e4c-a1a1-c1e96cf908c6" />

  可见停止模式进入条件比睡眠模式更加严苛，他需要在内核寄存器SLEEPDEEP位为1，PWR_CR寄存器PDDS为0时再调用WFI/WFE指令。当然，这个都被封装在了标准库中的PWR_EnterSTOPMode()

  退出的条件也更加严苛，只能是外设的中断/事件进行唤醒。

  功耗也比睡眠模式更低，应为停止模式把内核时钟,系统时钟,外设时钟全部关闭，外设无法以停止模式前的工作状态继续工作。无法执行程序，也无法烧录新程序。

  需要区分的是，GPIO会继续保持输入输出的模式，这不是没有停止工作，而是在stm32中，GPIO 的 “状态保持” 与 “功能运行” 是分离的。GPIO 的动态功能（如输出切换、输入中断）无法工作，因为这些操作依赖于时钟驱动的寄存器访问。但 GPIO 的静态状态（如输出电平、输入配置）会被硬件保持，因为它们由寄存器的物理状态决定，不依赖时钟。其他外设也是如此。本质上只是停止了所有的时钟。任何操作寄存器的操作无法执行，但是如果只是依赖硬件的操作仍然可以进行。

  如果是由中断唤醒(调用了WFI指令进入停止模式)唤醒后会先进入中断函数，退出中断服务后，接着执行停止模式后的程序；如果是由事件唤醒(调用WFE指令进入停止模式)，则直接接着执行停止模式后的程序。
  
  比较新奇有俩点。

  第一点是可以选择调压器的功耗模式，具体开启那个根据实际情况选择。其功能差别如下：

  <img width="723" height="349" alt="image" src="https://github.com/user-attachments/assets/b3907e57-2122-42a4-818b-f47647e5e56c" />

  第二点是唤醒后需要的操作

  停止模式唤醒后默认开启的是HSI时钟，这个和日常默认用的HSE时钟不一样，会导致USART串口通信为乱码，所以我们在唤醒停止模式后需要重新开启HSE时钟，操作请参考系统时钟一节。

  总结：要进入停止模式前， 需要在主函数开启PWR时钟，然后再调用PWR_EnterSTOPMode()函数。唤醒后第一时间调整系统时钟为HSE即可。
